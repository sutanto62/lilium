---
description: Core project rules for code organization, error handling, and general patterns
alwaysApply: true
---

# Project Rules

## Code Organization

### Clean Architecture Layers

- **Domain Layer** (`core/entities/`): Pure business entities, no dependencies
- **Application Layer** (`core/service/`): Business logic and use cases
- **Infrastructure Layer** (`core/repositories/`): Repository interfaces (ports)
- **Data Access Layer** (`lib/server/adapters/`): Database implementations (adapters)
- **Presentation Layer** (`routes/`): UI components and API endpoints

Dependencies must point inward: outer layers depend on inner layers, never the reverse.

### Import/Export Patterns

- Use path aliases: `$core`, `$src`, `$components`, `$adapters`
- Prefer named exports over default exports
- Use `import type` for type-only imports
- Import ordering: External dependencies → Internal modules → Path aliases

```typescript
// ✅ Good
import { eq, and } from 'drizzle-orm';
import type { ChurchEvent } from '$core/entities/Event';
import { ServiceError } from '$core/errors/ServiceError';
import { repo } from '$src/lib/server/db';
```

### File Structure

- One class/interface per file
- File names match exported class/interface name (PascalCase for classes, camelCase for utilities)
- Group related files in directories

## Reusability & DRY

- Prefer extracting shared logic into reusable functions, services, or utilities instead of copy-pasting code across routes or components.
- Keep domain logic inside `core/entities` and `core/service` so it can be reused from multiple adapters and routes.
- Reuse repository interfaces and adapters instead of creating feature-specific database access for the same entity.
- Favor composition over duplication when adding new features (extend existing services/utilities where reasonable before introducing new ones).
- When you see similar code in 2+ places, consider introducing a shared abstraction in the appropriate layer (domain, service, repository, adapter, or utility).

## Error Handling

### ServiceError Pattern

Always use `ServiceError` from `$core/errors/ServiceError.ts`:

```typescript
if (!event.church) {
  throw ServiceError.validation('Church ID is required', { field: 'church' });
}

const event = await repo.findEventById(id);
if (!event) {
  throw ServiceError.notFound('Event not found', { id });
}
```

### Error Propagation

- Catch errors at service boundaries
- Transform database errors to domain errors
- Log errors before re-throwing

```typescript
try {
  const result = await repo.insertEvent(newEvent);
  return result;
} catch (error) {
  logger.error('EventService.createEvent: Failed to insert event', { error });
  if (error instanceof ServiceError) throw error;
  throw ServiceError.unknown('System failed to record event', { originalError: error });
}
```

### Logging Standards

Format: `file_name + method name` (e.g., `EventService.createEvent`)

```typescript
import { logger } from '$src/lib/utils/logger';
logger.error('EventService.createEvent: Failed to insert event', { eventId, error });
```

## Async/Await Patterns

- Always use async/await over raw promises
- Handle errors explicitly
- Use Promise.all for parallel operations when appropriate

```typescript
async function retrieveEvents(weekNumbers: number[]): Promise<ChurchEvent[]> {
  try {
    return await repo.listEventsByWeekNumber(churchId, weekNumbers, false);
  } catch (error) {
    logger.error('EventService.retrieveEvents: Failed', { weekNumbers, error });
    throw ServiceError.database('Failed to retrieve events', { weekNumbers });
  }
}
```

## Performance Considerations

- Use database indexes for frequently queried columns
- Limit query results when appropriate
- Avoid N+1 query problems
- Use transactions for multiple related operations
- Minimize bundle size by avoiding unnecessary imports
