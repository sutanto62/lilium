---
description: TypeScript-specific rules and best practices
globs: **/*.ts
alwaysApply: true
---

# TypeScript Rules

## Type Safety Requirements

### No `any` Type

Never use `any`. Use `unknown` and narrow it:

```typescript
// ✅ Good
function handleError(error: unknown): string {
  if (error instanceof Error) return error.message;
  return 'Unknown error occurred';
}

// ❌ Bad
function handleError(error: any): string {
  return error.message;
}
```

### Explicit Return Types

Always specify return types for functions, especially public APIs:

```typescript
// ✅ Good
async function retrieveEventById(id: string): Promise<ChurchEvent> {
  const event = await repo.findEventById(id);
  if (!event) throw ServiceError.notFound('Event not found', { id });
  return event;
}

// ❌ Bad
async function getEvent(id: string) {
  return await repo.findEventById(id);
}
```

### Type Inference

Prefer type inference for local variables when types are obvious:

```typescript
const eventId = 'event-123';
const events = await repo.listEvents(churchId);
let event: ChurchEvent | null = null;
```

## Interface vs Type

### Use Interfaces for Objects

```typescript
// ✅ Good: Interface for entity
export interface ChurchEvent {
  id: string;
  church: string;
  mass: string;
  date: string;
  weekNumber?: number | null;
}

export interface ChurchEventResponse extends ChurchEvent {
  churchCode?: string | null;
}
```

### Use Type for Unions, Intersections, and Utilities

```typescript
// ✅ Good
export type EventType = 'mass' | 'feast';
export type CreateEventRequest = Omit<ChurchEvent, 'id' | 'createdAt'>;
export type EventWithDetails = ChurchEvent & { ushers: EventUsher[] };
```

## Utility Types

```typescript
export type CreateEventInput = Omit<ChurchEvent, 'id' | 'createdAt'>;
export type UpdateEventInput = Partial<Pick<ChurchEvent, 'code' | 'description' | 'date'>>;
export type EventSummary = Pick<ChurchEvent, 'id' | 'date' | 'description'>;
```

## Generic Constraints

```typescript
// ✅ Good
function findById<T extends { id: string }>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// ❌ Bad
function findById<T>(items: T[], id: string): T | undefined {
  return items.find(item => (item as any).id === id);
}
```

## Strict Null Checks

Always handle null/undefined explicitly:

```typescript
async function findEvent(id: string): Promise<ChurchEvent | null> {
  const result = await db.select().from(events).where(eq(events.id, id)).limit(1);
  return result[0] ?? null;
}

const event = await findEvent(id);
if (!event) {
  throw ServiceError.notFound('Event not found', { id });
}
```

## Type-Only Imports

Use `import type` for type-only imports:

```typescript
// ✅ Good
import type { ChurchEvent, EventUsher } from '$core/entities/Event';
import { EventType } from '$core/entities/Event';
```

## Function Overloads

```typescript
function retrieveEvents(weekNumber: number): Promise<ChurchEvent[]>;
function retrieveEvents(weekNumbers: number[]): Promise<ChurchEvent[]>;
function retrieveEvents(input: number | number[]): Promise<ChurchEvent[]> {
  const weekNumbers = Array.isArray(input) ? input : [input];
  return repo.listEventsByWeekNumber(churchId, weekNumbers, false);
}
```

## Type Guards

```typescript
function isChurchEvent(obj: unknown): obj is ChurchEvent {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'church' in obj &&
    'mass' in obj &&
    'date' in obj
  );
}
```

## Enums

```typescript
export enum EventType {
  MASS = 'mass',
  FEAST = 'feast'
}

const event: ChurchEvent = {
  id: '1',
  church: 'church-1',
  mass: 'mass-1',
  date: '2024-01-01',
  type: EventType.MASS
};
```
