---
description: Svelte 5 rules including runes, reactivity, component patterns, and best practices
globs: **/*.svelte
alwaysApply: true
---

# Svelte 5 Rules

- Prioritize Svelte 5, use runes for reactivity
- Never use Svelte 4 patterns (`export let`, `onMount`, stores)

## Runes Usage

### $props() for Component Props

```svelte
<script lang="ts">
  const { data, form } = $props<{
    data: PageProps['data'];
    form: PageProps['form'];
  }>();
</script>
```

### $state() for Reactive State

```svelte
<script lang="ts">
  let selectedDate = $state<Date | undefined>(undefined);
  let isSubmitting = $state(false);
</script>
```

### $derived() for Computed Values

```svelte
<script lang="ts">
  let event = $state<ChurchEvent | null>(null);
  let isLoading = $derived(event === null);
  
  const nextMonthInfo = $derived(() => {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    return {
      startDate: nextMonth.toISOString().split('T')[0],
      endDate: new Date(now.getFullYear(), now.getMonth() + 2, 0).toISOString().split('T')[0]
    };
  });
</script>
```

### $effect() for Side Effects

```svelte
<script lang="ts">
  import { page } from '$app/state';
  
  $effect(() => {
    const dateParam = page.url.searchParams.get('date');
    if (dateParam && selectedDate === undefined) {
      selectedDate = new Date(dateParam);
    }
  });
</script>
```

### $bindable() for Two-Way Binding

```svelte
<script lang="ts">
  let { value = $bindable<Date | undefined>() } = $props();
</script>
```

## Component Structure

Script section order:
1. Imports (external → internal → aliases)
2. Props with `$props()`
3. State with `$state()`
4. Derived with `$derived()`
5. Functions
6. Effects with `$effect()`

```svelte
<script lang="ts">
  // 1. Imports
  import { enhance } from '$app/forms';
  import { page } from '$app/state';
  import type { PageProps } from './$types';
  
  // 2. Props
  const { data, form } = $props<{ data: PageProps['data']; form: PageProps['form'] }>();
  
  // 3. State
  let selectedDate = $state<Date | undefined>(undefined);
  
  // 4. Derived
  const events = $derived(data.events);
  
  // 5. Functions
  function handleDateSelect(date: Date) { }
  
  // 6. Effects
  $effect(() => { });
</script>
```

## Server-Side vs Client-Side

### Server Components

Use `+page.server.ts` for server-side logic:

```typescript
export const load: PageServerLoad = async ({ params, url }) => {
  const events = await eventService.retrieveEventsByWeekRange({ weekNumber: 1 });
  return { events };
};
```

### Client Components

Keep client-side logic in `.svelte` files:

```svelte
<script lang="ts">
  let isSubmitting = $state(false);
  function handleSubmit() { isSubmitting = true; }
</script>
```

## Event Handling

### Use enhance() for Form Handling

```svelte
<form
  method="POST"
  use:enhance={() => {
    return async ({ update }) => {
      isSubmitting = true;
      await update();
      isSubmitting = false;
    };
  }}
>
```

### Inline Event Handlers

```svelte
<Button onclick={handleCancelBulkCreate}>Batal</Button>
<Button onclick={(e) => handleClick(e)}>Click</Button>
```

## Type Safety

Always type props, state, and function parameters:

```svelte
<script lang="ts">
  const { eventId = $bindable<string>() } = $props();
  let event = $state<ChurchEvent | null>(null);
  function handleEvent(event: ChurchEvent): void { }
</script>
```

## Prefer Runes Over Stores

```svelte
<!-- ✅ Good: Using runes -->
<script lang="ts">
  let count = $state(0);
  let doubled = $derived(count * 2);
</script>

<!-- ❌ Bad: Using stores (unless shared across components) -->
<script>
  import { writable } from 'svelte/store';
  const count = writable(0);
</script>
```
